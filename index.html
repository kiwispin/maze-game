<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Maze Flow</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

        body {
            font-family: 'Inter', sans-serif;
            background-color: #F5F5F7;
            /* Apple-like light gray */
            overflow: hidden;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
        }

        /* Glassmorphism UI */
        .glass-panel {
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.5);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.05);
        }

        .top-bar {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 80px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 24px;
            z-index: 50;
        }

        .top-pill {
            padding: 8px 16px;
            border-radius: 999px;
            font-weight: 600;
            color: #1D1D1F;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 15px;
        }

        .controls {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 16px;
            padding: 12px 24px;
            border-radius: 24px;
            z-index: 50;
            align-items: center;
        }

        .btn-icon {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            border: none;
            background: transparent;
            color: #1D1D1F;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .btn-icon:hover {
            background: rgba(0, 0, 0, 0.05);
            transform: scale(1.05);
        }

        .btn-icon:active {
            transform: scale(0.95);
        }

        .btn-primary {
            background: #007AFF;
            color: white;
            border: none;
            padding: 10px 24px;
            border-radius: 999px;
            font-weight: 600;
            font-size: 15px;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 4px 12px rgba(0, 122, 255, 0.3);
        }

        .btn-primary:hover {
            background: #0062CC;
            transform: translateY(-1px);
        }

        .btn-primary:active {
            transform: translateY(1px);
        }

        #game-container {
            position: absolute;
            top: 80px;
            bottom: 120px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }

        canvas {
            border-radius: 24px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.1);
            background: white;
            max-width: 95vw;
            max-height: 80vh;
        }

        /* Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(5px);
            z-index: 100;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .modal-overlay.show {
            opacity: 1;
            pointer-events: auto;
        }

        .modal-card {
            background: white;
            padding: 40px;
            border-radius: 32px;
            text-align: center;
            width: 90%;
            max-width: 360px;
            transform: scale(0.9);
            transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.15);
        }

        .modal-overlay.show .modal-card {
            transform: scale(1);
        }

        /* Dropdown */
        .dropdown-menu {
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 8px;
            background: white;
            border-radius: 16px;
            padding: 8px;
            min-width: 160px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1);
            opacity: 0;
            transform: translateY(-10px);
            pointer-events: none;
            transition: all 0.2s ease;
            z-index: 60;
        }

        .dropdown-menu.show {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }

        .dropdown-item {
            padding: 10px 16px;
            border-radius: 12px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: #1D1D1F;
            font-weight: 500;
            font-size: 14px;
        }

        .dropdown-item:hover {
            background: #F5F5F7;
        }

        .dropdown-item.active {
            color: #007AFF;
            background: rgba(0, 122, 255, 0.1);
        }

        /* Screen Shake */
        @keyframes shake {

            0%,
            100% {
                transform: translateX(0);
            }

            25% {
                transform: translateX(-5px);
            }

            75% {
                transform: translateX(5px);
            }
        }

        .shake-screen {
            animation: shake 0.3s cubic-bezier(.36, .07, .19, .97) both;
        }

        #flash {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 59, 48, 0.3);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.1s ease;
            z-index: 90;
        }
    </style>
</head>

<body>
    <div id="flash"></div>

    <!-- Top Bar -->
    <div class="top-bar glass-panel">
        <div class="top-pill">
            <span class="text-gray-500">Errors</span>
            <span id="error-count" class="text-red-500">0</span>
        </div>

        <div class="relative">
            <div id="difficultyMenu" class="dropdown-menu">
                <div class="dropdown-item" onclick="setDifficulty(15, 'Easy')">Easy</div>
                <div class="dropdown-item active" onclick="setDifficulty(20, 'Medium')">
                    Medium
                    <svg class="check-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16"
                        viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round"
                        stroke-linejoin="round">
                        <polyline points="20 6 9 17 4 12"></polyline>
                    </svg>
                </div>
                <div class="dropdown-item" onclick="setDifficulty(30, 'Hard')">Hard</div>
                <div style="height: 1px; background: #E5E5EA; margin: 4px 0;"></div>
                <div class="dropdown-item" id="strictModeToggle" onclick="toggleStrict()">
                    Strict Mode
                </div>
            </div>

            <div class="glass-panel top-pill dropdown-trigger" onclick="toggleDropdown(event)">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none"
                    stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                    <polygon points="12 2 2 7 12 12 22 7 12 2"></polygon>
                    <polyline points="2 17 12 22 22 17"></polyline>
                    <polyline points="2 12 12 17 22 12"></polyline>
                </svg>
                <span id="difficultyLabel">Medium</span>
                <svg class="chevron ml-1 opacity-50" xmlns="http://www.w3.org/2000/svg" width="14" height="14"
                    viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round"
                    stroke-linejoin="round">
                    <polyline points="6 9 12 15 18 9"></polyline>
                </svg>
            </div>
        </div>
    </div>

    <!-- Game Canvas -->
    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
    </div>

    <!-- Bottom Controls -->
    <div class="controls glass-panel">
        <button class="btn-icon" onclick="toggleSound()" id="soundBtn" title="Toggle Sound">
            <svg id="icon-sound-on" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24"
                fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
                <path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path>
            </svg>
            <svg id="icon-sound-off" class="hidden" xmlns="http://www.w3.org/2000/svg" width="20" height="20"
                viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                stroke-linejoin="round">
                <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
                <line x1="23" y1="9" x2="17" y2="15"></line>
                <line x1="17" y1="9" x2="23" y2="15"></line>
            </svg>
        </button>

        <div style="width: 1px; height: 24px; background: rgba(0,0,0,0.1);"></div>

        <button class="btn-primary" onclick="generateNewGame()">New Maze</button>

        <button class="btn-icon" onclick="clearDrawing()" title="Clear Path">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none"
                stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M3 3h18v18H3zM15 9l-6 6m0-6l6 6" />
            </svg>
        </button>
    </div>

    <!-- Success Modal -->
    <div class="modal-overlay" id="successModal">
        <div class="modal-card">
            <div
                class="w-16 h-16 bg-green-100 text-green-500 rounded-full flex items-center justify-center mx-auto mb-4">
                <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none"
                    stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round">
                    <polyline points="20 6 9 17 4 12"></polyline>
                </svg>
            </div>
            <h2 class="text-2xl font-bold mb-2 text-gray-900">Maze Clear!</h2>
            <p class="text-gray-500 mb-6">You navigated the maze with <span id="final-errors"
                    class="font-bold text-gray-900">0</span> errors.</p>
            <button class="btn-primary w-full py-3" onclick="closeModalAndReset()">Play Again</button>
        </div>
    </div>

    <script>
        // --- CONFIGURATION ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('game-container');
        const errorDisplay = document.getElementById('error-count');
        const flashOverlay = document.getElementById('flash');

        // State
        let cols, rows;
        let cellSize;
        let grid = [];
        let stack = [];
        let walls = [];
        let startCell, endCell;
        let isMuted = false;
        let currentDifficulty = 20;
        let strictMode = false;

        // Drawing State
        let isDrawing = false;
        let isGameActive = true;
        let lastPos = { x: 0, y: 0 };
        let userPath = [];
        let errorCount = 0;
        let collisionPoints = [];

        // Audio
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();

        // --- MAZE GENERATION ---
        class Cell {
            constructor(c, r) {
                this.c = c;
                this.r = r;
                this.walls = [true, true, true, true]; // Top, Right, Bottom, Left
                this.visited = false;
            }
        }

        function index(c, r) {
            if (c < 0 || r < 0 || c >= cols || r >= rows) return -1;
            return c + r * cols;
        }

        function generateMaze() {
            isGameActive = true;
            document.getElementById('successModal').classList.remove('show');

            const diff = currentDifficulty;
            const margin = 30; // Margin around canvas
            const uiHeight = 220; // Space for top/bottom UI

            const w = window.innerWidth - margin * 2;
            const h = window.innerHeight - uiHeight;

            cellSize = Math.floor(Math.min(w, h) / (diff / 2 + 5)); // Responsive scaling

            cols = Math.floor(w / cellSize);
            rows = Math.floor(h / cellSize);

            // Limit minimum size
            cols = Math.max(cols, 3);
            rows = Math.max(rows, 3);

            // Set canvas size
            canvas.width = cols * cellSize;
            canvas.height = rows * cellSize;

            // Reset
            grid = [];
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    grid.push(new Cell(c, r));
                }
            }

            // Generate
            let current = grid[0];
            current.visited = true;
            stack = [];
            let finished = false;

            while (!finished) {
                const next = checkNeighbors(current);
                if (next) {
                    next.visited = true;
                    stack.push(current);
                    removeWalls(current, next);
                    current = next;
                } else if (stack.length > 0) {
                    current = stack.pop();
                } else {
                    finished = true;
                }
            }

            // Define Goals
            startCell = { x: 0, y: 0, w: cellSize, h: cellSize };
            endCell = { x: (cols - 1) * cellSize, y: (rows - 1) * cellSize, w: cellSize, h: cellSize };

            buildWallRects();
            clearDrawing();
        }
        const generateNewGame = generateMaze;

        function checkNeighbors(cell) {
            let neighbors = [];
            const top = grid[index(cell.c, cell.r - 1)];
            const right = grid[index(cell.c + 1, cell.r)];
            const bottom = grid[index(cell.c, cell.r + 1)];
            const left = grid[index(cell.c - 1, cell.r)];

            if (top && !top.visited) neighbors.push(top);
            if (right && !right.visited) neighbors.push(right);
            if (bottom && !bottom.visited) neighbors.push(bottom);
            if (left && !left.visited) neighbors.push(left);

            if (neighbors.length > 0) {
                return neighbors[Math.floor(Math.random() * neighbors.length)];
            }
            return undefined;
        }

        function removeWalls(a, b) {
            const x = a.c - b.c;
            if (x === 1) { a.walls[3] = false; b.walls[1] = false; }
            else if (x === -1) { a.walls[1] = false; b.walls[3] = false; }
            const y = a.r - b.r;
            if (y === 1) { a.walls[0] = false; b.walls[2] = false; }
            else if (y === -1) { a.walls[2] = false; b.walls[0] = false; }
        }

        // --- COLLISION SYSTEM ---
        function buildWallRects() {
            walls = [];
            const thickness = 8; // Thicker, nicer walls
            const offset = thickness / 2;

            // Borders
            walls.push({ x: 0, y: 0, w: canvas.width, h: thickness });
            walls.push({ x: 0, y: canvas.height - thickness, w: canvas.width, h: thickness });
            walls.push({ x: 0, y: 0, w: thickness, h: canvas.height });
            walls.push({ x: canvas.width - thickness, y: 0, w: thickness, h: canvas.height });

            // Inner Walls
            for (let i = 0; i < grid.length; i++) {
                const c = grid[i];
                const x = c.c * cellSize;
                const y = c.r * cellSize;

                // Right Wall
                if (c.walls[1]) {
                    walls.push({ x: x + cellSize - offset, y: y - offset, w: thickness, h: cellSize + thickness });
                }
                // Bottom Wall
                if (c.walls[2]) {
                    walls.push({ x: x - offset, y: y + cellSize - offset, w: cellSize + thickness, h: thickness });
                }
            }
        }

        function lineIntersectsRect(p1, p2, rect) {
            const minX = Math.min(p1.x, p2.x);
            const maxX = Math.max(p1.x, p2.x);
            const minY = Math.min(p1.y, p2.y);
            const maxY = Math.max(p1.y, p2.y);

            // Expand rect slightly for strict collision
            const padding = 2;

            if (maxX < rect.x + padding || minX > rect.x + rect.w - padding || maxY < rect.y + padding || minY > rect.y + rect.h - padding) {
                return false;
            }
            return true;
        }

        // --- RENDERER ---
        function render() {
            // Background
            ctx.fillStyle = "#FFFFFF";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Animation State
            const time = performance.now() / 1000;
            const pulse = (Math.sin(time * 3) + 1) / 2; // 0 to 1

            // --- Draw Start Zone ---
            // Proportional Sizing
            const padding = cellSize * 0.15; // 15% padding
            const sx = startCell.x + padding;
            const sy = startCell.y + padding;
            const sw = cellSize - (padding * 2);
            const sh = cellSize - (padding * 2);
            const scx = startCell.x + cellSize / 2;
            const scy = startCell.y + cellSize / 2;

            // Pulsing Glow (Underneath)
            ctx.save();
            ctx.translate(scx, scy);
            const startScale = 1 + (pulse * 0.15);
            ctx.scale(startScale, startScale);
            ctx.beginPath();
            ctx.arc(0, 0, (sw / 2), 0, Math.PI * 2); // Use proportional radius
            ctx.fillStyle = "rgba(52, 199, 89, 0.3)"; // Success color low opacity
            ctx.fill();
            ctx.restore();

            // Main Circle
            ctx.beginPath();
            ctx.arc(scx, scy, (sw / 2), 0, Math.PI * 2);
            const gradStart = ctx.createLinearGradient(sx, sy, sx + sw, sy + sh);
            gradStart.addColorStop(0, '#34C759'); // Apple Success Green
            gradStart.addColorStop(1, '#248A3D');
            ctx.fillStyle = gradStart;
            ctx.shadowColor = "rgba(0,0,0,0.15)"; // Reduced shadow opacity
            ctx.shadowBlur = padding * 0.5; // Proportional shadow blur
            ctx.shadowOffsetY = padding * 0.2;
            ctx.fill();
            ctx.shadowColor = "transparent"; // Reset shadow

            // Start Icon (Simple White Dot)
            ctx.beginPath();
            ctx.arc(scx, scy, cellSize * 0.12, 0, Math.PI * 2); // Slightly smaller dot
            ctx.fillStyle = "white";
            ctx.fill();


            // --- Draw End Zone ---
            const ex = endCell.x + padding;
            const ey = endCell.y + padding;
            const ew = cellSize - (padding * 2);
            // eh is same as ew since it's a square cell
            const ecx = endCell.x + cellSize / 2;
            const ecy = endCell.y + cellSize / 2;

            // Pulsing Glow
            ctx.save();
            ctx.translate(ecx, ecy);
            const endScale = 1 + (pulse * 0.15);
            ctx.scale(endScale, endScale);
            ctx.beginPath();
            ctx.arc(0, 0, (ew / 2), 0, Math.PI * 2);
            ctx.fillStyle = "rgba(255, 59, 48, 0.3)"; // Danger color low opacity
            ctx.fill();
            ctx.restore();

            // Main Circle
            ctx.beginPath();
            ctx.arc(ecx, ecy, (ew / 2), 0, Math.PI * 2);
            const gradEnd = ctx.createLinearGradient(ex, ey, ex + ew, ey + ew);
            gradEnd.addColorStop(0, '#FF3B30'); // Apple Danger Red
            gradEnd.addColorStop(1, '#D70015');
            ctx.fillStyle = gradEnd;
            ctx.shadowColor = "rgba(0,0,0,0.15)";
            ctx.shadowBlur = padding * 0.5;
            ctx.shadowOffsetY = padding * 0.2;
            ctx.fill();
            ctx.shadowColor = "transparent";

            // End Icon (Bullseye Target)
            // Outer Ring
            ctx.beginPath();
            ctx.arc(ecx, ecy, cellSize * 0.22, 0, Math.PI * 2); // Proportional size
            ctx.strokeStyle = "rgba(255, 255, 255, 0.9)";
            ctx.lineWidth = cellSize * 0.05; // Proportional line width
            ctx.stroke();

            // Inner Dot
            ctx.beginPath();
            ctx.arc(ecx, ecy, cellSize * 0.08, 0, Math.PI * 2);
            ctx.fillStyle = "white";
            ctx.fill();

            // Border Ring for End (Subtle outer rim)
            ctx.beginPath();
            ctx.arc(ecx, ecy, (ew / 2), 0, Math.PI * 2);
            ctx.strokeStyle = "rgba(255,255,255,0.3)";
            ctx.lineWidth = 2;
            ctx.stroke();

            // Draw Path with Glow
            if (userPath.length > 0) {
                ctx.shadowBlur = 10;
                ctx.shadowColor = "rgba(0, 122, 255, 0.5)"; // Blue Glow
                ctx.strokeStyle = "#007AFF";
                ctx.lineWidth = 6;
                ctx.lineCap = "round";
                ctx.lineJoin = "round";

                ctx.beginPath();
                let active = false;
                for (let i = 0; i < userPath.length; i++) {
                    const p = userPath[i];
                    if (p === null) {
                        active = false;
                    } else {
                        if (!active) {
                            ctx.moveTo(p.x, p.y);
                            active = true;
                        } else {
                            ctx.lineTo(p.x, p.y);
                        }
                    }
                }
                ctx.stroke();
                ctx.shadowBlur = 0;
            }

            // Draw Walls
            ctx.fillStyle = "#1D1D1F";
            walls.forEach(w => {
                roundRect(ctx, w.x, w.y, w.w, w.h, 4);
                ctx.fill();
            });

            // Collision Dots
            collisionPoints.forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, 6, 0, Math.PI * 2);
                ctx.fillStyle = "#FF3B30";
                ctx.fill();
                ctx.strokeStyle = "white";
                ctx.lineWidth = 2;
                ctx.stroke();
            });
        }

        function roundRect(ctx, x, y, w, h, r) {
            if (w < 2 * r) r = w / 2;
            if (h < 2 * r) r = h / 2;
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.arcTo(x + w, y, x + w, y + h, r);
            ctx.arcTo(x + w, y + h, x, y + h, r);
            ctx.arcTo(x, y + h, x, y, r);
            ctx.arcTo(x, y, x + w, y, r);
            ctx.closePath();
        }

        // --- INTERACTION ---
        function getPos(e) {
            const rect = canvas.getBoundingClientRect();
            let x = e.clientX || e.touches[0].clientX;
            let y = e.clientY || e.touches[0].clientY;
            return { x: x - rect.left, y: y - rect.top };
        }

        function startDrawing(e) {
            if (!isGameActive) return;
            // Ignore touches on UI
            if (e.target.closest('.controls') || e.target.closest('.top-bar')) return;

            const pos = getPos(e);
            const leeway = 10;

            // Check if starting at Start Cell
            const isAtStart = (pos.x >= startCell.x - leeway && pos.x <= startCell.x + startCell.w + leeway &&
                pos.y >= startCell.y - leeway && pos.y <= startCell.y + startCell.h + leeway);

            // Check if resuming from last point
            let isResuming = false;
            if (userPath.length > 0) {
                const lastPoint = userPath[userPath.length - 1];
                if (lastPoint) {
                    const dist = Math.hypot(pos.x - lastPoint.x, pos.y - lastPoint.y);
                    if (dist < cellSize) {
                        // Allow resuming within 1 cell size distance
                        isResuming = true;
                    }
                }
            }

            // Enforcement Logic
            let canStart = false;

            if (userPath.length === 0) {
                // First move must be at start
                if (isAtStart) canStart = true;
            } else {
                if (strictMode) {
                    // Strict Mode: Must always restart from start if you lift your finger
                    if (isAtStart) {
                        // If restarting at start, clear old path
                        userPath = [];
                        collisionPoints = [];
                        errorCount = 0;
                        errorDisplay.innerText = 0;
                        canStart = true;
                    }
                } else {
                    // Normal Mode: Can resume OR restart
                    if (isResuming) canStart = true;
                    if (isAtStart) {
                        // Optional: Could clear path here too if they want to restart, 
                        // but for now let's just allow drawing. 
                        // Better UX: If they go back to start, maybe they want to restart?
                        // Let's keep it simple: If they touch start, they can draw. 
                        // If they touch near end of path, they can draw.
                        canStart = true;
                    }
                }
            }

            if (!canStart) return;

            isDrawing = true;
            lastPos = pos;
            if (userPath.length === 0) {
                userPath.push(lastPos);
            } else {
                // If resuming, don't add a gap, just continue
                // If restarting (jumping back to start), we might want a gap or clear.
                // For simplicity in this logic:
                userPath.push(null); // Break line
                userPath.push(lastPos);
            }

            if (audioCtx.state === 'suspended') audioCtx.resume();
            render();
        }

        function draw(e) {
            if (!isDrawing || !isGameActive) return;
            e.preventDefault();

            const currentPos = getPos(e);

            // Wall Collision
            let hit = false;
            for (let w of walls) {
                if (lineIntersectsRect(lastPos, currentPos, w)) {
                    hit = true;
                    break;
                }
            }

            if (hit) {
                handleCollision(currentPos);
                isDrawing = false;
                return;
            }

            // Win Condition
            if (currentPos.x > endCell.x && currentPos.y > endCell.y) {
                handleWin();
                return;
            }

            userPath.push(currentPos);
            lastPos = currentPos;
            requestAnimationFrame(render);
        }

        function stopDrawing() {
            isDrawing = false;
        }

        function handleCollision(pos) {
            errorCount++;
            errorDisplay.innerText = errorCount;
            collisionPoints.push(pos);

            flashOverlay.style.opacity = '0.3';
            container.classList.add('shake-screen');
            playBuzzSound();
            render();

            setTimeout(() => {
                flashOverlay.style.opacity = '0';
                container.classList.remove('shake-screen');
            }, 300);
        }

        function handleWin() {
            isGameActive = false;
            isDrawing = false;
            render();

            if (!isMuted) {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'sine';

                const now = audioCtx.currentTime;
                osc.frequency.setValueAtTime(523.25, now);
                osc.frequency.setValueAtTime(659.25, now + 0.1);
                osc.frequency.setValueAtTime(783.99, now + 0.2);
                osc.frequency.setValueAtTime(1046.50, now + 0.3);

                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.6);

                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(now + 0.6);
            }

            document.getElementById('final-errors').innerText = errorCount;
            document.getElementById('successModal').classList.add('show');
        }

        function playBuzzSound() {
            if (isMuted) return;
            try {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.value = 60;

                const now = audioCtx.currentTime;
                gain.gain.setValueAtTime(0.15, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);

                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(now + 0.2);
            } catch (e) { }
        }

        // --- UI UTILS ---
        function toggleDropdown(e) {
            e.stopPropagation();
            const menu = document.getElementById('difficultyMenu');
            menu.classList.toggle('show');
        }

        function closeDropdown(e) {
            const menu = document.getElementById('difficultyMenu');
            if (menu.classList.contains('show')) {
                menu.classList.remove('show');
            }
        }

        function setDifficulty(value, label) {
            currentDifficulty = value;
            document.getElementById('difficultyLabel').innerText = label;

            // Update Active State
            const items = document.querySelectorAll('.dropdown-item');
            items.forEach(item => {
                if (item.id === 'strictModeToggle') return; // Skip strict toggle

                // Reset styling
                item.classList.remove('active');
                if (item.querySelector('.check-icon')) {
                    item.querySelector('.check-icon').remove();
                }

                // Set active if matches
                if (item.innerText.includes(label)) {
                    item.classList.add('active');
                    item.innerHTML += `<svg class="check-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>`;
                }
            });

            generateNewGame();
        }

        function toggleStrict() {
            strictMode = !strictMode;
            const item = document.getElementById('strictModeToggle');
            if (strictMode) {
                item.classList.add('active');
                if (!item.querySelector('.check-icon')) {
                    item.innerHTML += `<svg class="check-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>`;
                }
            } else {
                item.classList.remove('active');
                if (item.querySelector('.check-icon')) {
                    item.querySelector('.check-icon').remove();
                }
            }
        }

        function clearDrawing() {
            userPath = [];
            collisionPoints = [];
            errorCount = 0;
            errorDisplay.innerText = 0;
            isGameActive = true;
            document.getElementById('successModal').classList.remove('show');
            render();
        }

        function closeModalAndReset() {
            generateNewGame();
        }

        function toggleSound() {
            isMuted = !isMuted;
            document.getElementById('icon-sound-on').classList.toggle('hidden');
            document.getElementById('icon-sound-off').classList.toggle('hidden');
        }

        // Event Listeners
        window.addEventListener('resize', () => {
            setTimeout(generateMaze, 100);
        });

        // Mouse
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseout', stopDrawing);

        // Touch
        canvas.addEventListener('touchstart', startDrawing, { passive: false });
        canvas.addEventListener('touchmove', draw, { passive: false });
        canvas.addEventListener('touchend', stopDrawing);

        // Init
        setTimeout(generateMaze, 100);
    </script>
</body>

</html>